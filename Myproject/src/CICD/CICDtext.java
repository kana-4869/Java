

/*
 開発者
①ソースコードをcompileとコード分析する
②ローカルでJunitテスト：
・・ok→docker image
(backup:実行したソースコードを静的モードにパッケージする)
→作成したdocker imageをECRのレポジトリーに保存する。

・・NG→自動的にjira起票或はslackお知らせ、
・CIで行われたテストの結果により、問題があるものをjiraで登録
・開発責任者は対応可否を判断して、開発者に連携する。  
・開発者が修正した後に、再度Junitテストが行われ、上記の手順が自動的にリサイクル。


devの場合、多分github actionの後、ECRに保存
stg：デプロイの後、ECRに保存

以上のすべての流れはログファイルがあって、AWSクラウドに保存する。


ECR:docerimageを保存するレポジトリー（倉庫）
ECS:コンテナを管理するAWSのサービスです。
S3:AWSのデータ保存サービスです。
保存対象：ウェブサイト、モバイルアプリケーション、バックアップ、ビッグデータ分析データ。
Jenkins：開発のビルド 、 テスト 、およびデプロイに関連する部分の自動化を支援できるサーバーです。
API gateway:クライアントから受け取ったリクエストを、それぞれのマイクロサービスにルーティングします。
PrivateLink:AWSへのAPIアクセスをインターネットを経由せずに行えるインターフェースタイプのVPCエンドポイント
vpc endpoint:VPCと他のサービス間の通信を可能にできるコンポネントです。
load balancer(负载均衡器):受信したリクエストをそれぞれのサービスのターゲットグループに分散します。
集群:インスタンス群
container:コンテナ 容器
codepipeline:ソースリポジトリからビルド、テスト、デプロイまで、リリースプロセスを完全に自動化します

ECSのインスタンス群を作成して、そしてこのインスタンス群でdockerイメージをデプロイする
そして、ロードバランサーを使って、クライアントからのリクエストを平均的にそれぞれのコンテナに分散します

■基盤の概念：

基盤とはインフラとも言います、主に情報  システムを運用するための土台となるコンピューターなどを設置する
施設間を結ぶ通信回線、データなどの全体がデジタル基盤です。

■インフラのドラフト図の説明メモ：

今回のAPI基盤はGC側自分で作って、定義したものです、9月の時、また変わる可能性があります：
枠の中にはfrontサーバー：applicationサーバー：fargate1と2があり、
javaで作ったwarファイルをデプロイするサーバです。その裏にデータベースがあります。
なぜfargateが二つあるというと、マルチ構成では、availability zoneという概念があって、
万が一AZ1が落ちても、AZ2が正常に動くというのが目的です。

aws上はvpcという概念があって、いわゆるprivateネットワークです、この中のリソースは内部しかアクセスできない、
外部からアクセスするたびにVPC endpointの穴を作る必要があります、穴を通して、来るリクエストはロードバランサーを通して、
それぞれのサービスに分散する。ロードバランサーはあくまで郵便局みたいな物で、郵便物がくる場合、どこに配るかを決めるものです。

VPC endpointの表にさらにAPI gatewayがあり、 gatewayというのが、来てるリクエストが有効であるかどうかをチェックする役割です。
許可するリクエストだけを通させる、

enduserから見ると、まず、リクエストがAPI gatewayに行きます、
API gatewayで有効のチェックを通して、VPC endpointを通して、ロードバランサーに行くんです。
ロードバランサーで、それがapplicationのリクエストなのか、vehicleなのかを確認して、それぞれのサービスに振ります

dev環境のインフラ：ビルドからデプロイまでの流れ

1.Githubにコミットしたソースコードをjenkinsでビルド、
2.jenkinsでwarファイルをS3にpushする
3.S3がcodepipelineをトリガーする。（CPLを開始させる？）
4.codepipelineは三つの段階があります。s3、codebuild、ecs
5.ビルドしたcodeはdockerイメージ作成して、ECRサービスにpushする
6.ECSのインスタンス群を作成して、そしてこのインスタンス群で最新のdockerイメージをデプロイする 
